<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{A Markdown Vignette with knitr}
-->

```{r setup, include=FALSE}
# set global chunk options
library(knitr)
opts_chunk$set(cache=FALSE)

## Function for embedding high qual text images:
uri_embed <- function(path, add="") {
    uri <- knitr::image_uri(path)
    cat(paste0("<img ", add, " src=\"", uri, "\" />"))
}
opts_knit$set(upload.fun = image_uri, self.contained=TRUE)
```

<h1 class="title">Introduction to pacman</h1>
<h1 class="auth">Tyler W. Rinker & Dason Kurkiewicz</h1>

The **pacman** package is an R package management tool that combines the functionality of base `library` related functions into intuitively named functions.  This package is ideally added to [.Rprofile](http://stat.ethz.ch/R-manual/R-patched/library/base/html/Startup.html) to increase workflow by reducing time recalling obscurely named functions, reducing code, and integrating functionality of base functions to simultaneously perform multiple actions.  The function `p_load` is particularly well suited for help forums and posts, as it will load and, if necessary, install missing packages.


```{r, echo=FALSE, results='asis'}
uri_embed("r_pacman.png", 
    "width=\"350\", height=\"150\" style=\"display:block; margin-left:auto; margin-right:auto;\"")
```


Function names in the pacman package follow the format of `p_xxx` where 'xxx' is the task the function performs.  For instance the `p_load` function allows the user to load one or more packages as a more generic substitute for the `library` or `require` functions and if the package isn't available locally it will install it for you.  In keeping with the `library` function, the user need not use quotes around package names for most **pacman* functions.

## Installing, Loading, Unloading, Updating, & Deleting   

**Quick Reference Table** 

| pacman Function | Base Equivalent | Description |
|----------------------|----------------------|----------------|
| `p_load`  |  `install.packages` + `library` | Loads and Install Packages |
| `p_install` |  `install.packages` | Install Packages from CRAN |
| `p_temp` |  NONE | Install a Package Temporarily |
| `p_unload` | `detach` | Unloads Packages from the Search Path |
| `p_update` | `update.packages` | Update Out-of-Date Packages |

The heart of **pacman** is it's ability to reduce typing in package management actions.  The functions in this section The functions in this section ***act*** on packages.  

### Installing and Loading    

`p_load` is a general use tool that can install, load, and update packages.  The form for the function is:

```{r, eval = FALSE}
p_load(..., char, install = TRUE, update = getOption("pac_update"), character.only = FALSE)
```

where the `...` argument allows the user to pass in quoted (or unquoted) package names.  For example, many blog posts begin coding with this sort of package call:

```{r eval=FALSE}
packs <- c("XML", "devtools", "RCurl", "fakePackage", "SPSSemulate")
success <- suppressWarnings(sapply(packs, require, character.only = TRUE))
install.packages(names(success)[!success])
sapply(names(success)[!success], require, character.only = TRUE)
```

With pacman this call can be reduced to:

```{r eval=FALSE}
pacman::p_load(XML, devtools, RCurl, fakePackage, SPSSemulate)
```

#### Just Installing 

The user may wish to only install packages.  The `p_install` (aliased as `p_get`) will allow the user to install with the same ease of format as `p_load`.  For example: 

```{r eval=FALSE}
p_install(dbConnect, qdap, reports)
```

### Installing Temporarily

Lastly, `p_temp` enables the user to temporarily install a package.  This allows a session only install for testing out a single package without muddying the user's library.  

```{r eval=FALSE}
p_temp(aprof)

p_isinstalled(aprof)
p_isloaded(aprof)
```

<pre><code>> p_temp(aprof)
trying URL 'http://cran.rstudio.com/bin/windows/contrib/3.1/aprof_0.2.zip'
Content type 'application/zip' length 34037 bytes (33 Kb)
opened URL
downloaded 33 Kb

package 'aprof' successfully unpacked and MD5 sums checked

The downloaded binary packages are in
        C:\Users\you\AppData\Local\Temp\RtmpYh6bSr\downloaded_packages

aprof installed
Loading required package: aprof
> 
> p_isinstalled(aprof)
[1] FALSE
> p_isloaded(aprof)
aprof 
 TRUE 
</code></pre>

<div class="notebox", style="background-color: #FFFFCC;"> 
<b>Note:</b>  When using <code>p_load</code> and friends inside of functions the user may want to explicitly supply the package name(s) as character strings and set <code>character.only = FALSE</code> or supply a character vector of package names directly to the <code>char</code> argument if it is available.
</div>

       
###  Unloading

To unload package(s) from the search path use `p_unload`.  `p_unload` will not unload the base install packages that load when R boots up. The form for the function is:

```{r, eval = FALSE}
p_unload(..., negate = FALSE, char, character.only = FALSE)
```

where the `...` argument allows the user to pass in quoted package names.  Users may also supply `"all"` to `...`  to remove all add on packages.  The `negate` argument negates, unloading all packages except those supplied to `...`.

```{r, eval = FALSE}
p_load(lattice)
p_isloaded(lattice)
p_unload(lattice)
p_isloaded(lattice)
```

<pre><code>> p_load(lattice)
> p_isloaded(lattice)
lattice 
   TRUE 
> p_unload(lattice)
The following packages have been unloaded:
lattice

> p_isloaded(lattice)
lattice 
  FALSE 
</code></pre>

### Updating    
  
The `p_update` (aliased as `p_up`) is a wrapper for `update.packages` (defaults to `ask = FALSE`) and `old.packages`. To update packages use:

```{r, eval = FALSE}
p_update() 
```

The user may just query (not actually update) for out-of-date packages using:

```{r, eval = FALSE}
p_update(FALSE) 
```

### Deleting   
  
The task of recalling the name `remove.packages` for permanently deleting a package from your library has been replaced by the more consistently named `p_delete` (aliased as `p_del`).  Additionally, the user may delete multiple packages in a single call.  The function protects the user from accidental attempted base package deletion as it will not delete base installed packages (see `installed.packages(priority = "base")`).  Try it out:

```{r, eval = FALSE}
p_delete(fakePackage, stats)
```

<pre><code>> p_delete(fakePackage, stats)
The following packages are a base install and will not be deleted:
stats

The following packages not found in library:
fakePackage
</code></pre>

## Session Information   

**Quick Reference Table** 

| pacman Function | Base Equivalent | Description |
|----------------------|----------------------|----------------|
| `p_loaded`  |  `.packages` & `sessionInfo` | List Attached Packages |
| `p_isloaded`  |  NONE | Logical Test of Attached Package |


##  Local Package Information    

**Quick Reference Table** 

| pacman Function | Base Equivalent | Description |
|----------------------|----------------------|----------------|
| `p_author`  | `packageDescription`  | Author of Package|
| `p_citation`  | `citation`  | Citation for Package |
| `p_data`  | `data`  | List Package Data Sets |
| `p_exists`  | `available.packages` & <br>`list.files` + `.libPaths` | Logical Check if Package Exists Locally/on CRAN |
| `p_functions`  | `loadNamespace` + `getNamespaceExports`  | Functions from Package |
| `p_help`  | `help`  | HTML/PDF Manuals Viewing |
| `p_information`  | `packageDescription`  |Information for Package |
| `p_interactive` | NONE  | Search Packages Interactively |
| `p_news`  | `news`  | Package NEWS |
| `p_version`  | `packageDescription` & `R.Version`  | Version of Package |
| `p_vignette`  | `browseVignettes`  | Package Vignettes Viewing |


-  `p_author`
-  `p_cite`/`p_citation`
-  `p_data`
-  `p_exists`/`p_isinstalled`  
-  `p_funs`/`p_functions`
-  `p_help`
-  `p_info`/`p_information`
-  `p_inter`/`p_interactive`
-  `p_news`
-  `p_ver`/`p_version`
-  `p_vign`/`p_vignette`


## Internet Based Package Information  

**Quick Reference Table** 

| pacman Function | Base Equivalent | Description |
|----------------------|----------------------|----------------|
| `p_cran`  | `available.package`  | List CRAN Package |
| `p_search_any`  | NONE | Search for Package by Author |


-  `p_cran`
-  `p_search_any`/`p_sa`

## Library Information     

**Quick Reference Table** 

| pacman Function | Base Equivalent | Description |
|----------------------|----------------------|----------------|
| `p_base`  | NONE | List Base Package |
| `p_library`  | `Sys.getenv` + `.packages` | List Packages in User's Library |
| `p_path`  | `.libPaths`  | Path to User's Package Library |
| `p_search_library`  | NONE | Search Library Packages Via Partial Matching |
| `p_unlock` | NONE  | Deletes 00LOCK Directory |


- `p_base`
- `p_lib`/`p_library`
- `p_path`
- `p_sl`/`p_search_library`
- `p_unlock`

## pacman Tools   

**Quick Reference Table** 

| pacman Function | Base Equivalent | Description |
|----------------------|----------------------|----------------|
| `p_detectOS`   | `Sys.info` | Detect Operating System |
| `p_extract`   | NONE | Extract Packages from String |
| `p_opendir`  | `system`/`shell`  | Open a Directory |


- `p_detectOS` 
- `p_extract`
- `p_opendir`   

```{r css, echo = FALSE}
options(markdown.HTML.stylesheet = "css/style.css")
```

## References
```{r, echo=FALSE, message=FALSE}
#write.bibtex(file="references.bib")
```

```{r clean-up, include=FALSE}
# R compiles all vignettes in the same session, which can be bad
rm(list = ls(all = TRUE))
```
