<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Introduction to pacman}
-->

```{r setup, include=FALSE}
# set global chunk options
library(knitr); library(pacman); library(methods)
opts_chunk$set(cache=FALSE, comment=NA)

## Function for embedding high qual text images:
uri_embed <- function(path, add="") {
    uri <- knitr::image_uri(path)
    cat(paste0("<img ", add, " src=\"", uri, "\" />"))
}
opts_knit$set(upload.fun = image_uri, self.contained=TRUE)

## set mirror
options(repos="http://cran.rstudio.com/")
```

<h1 class="title">Introduction to pacman</h1>
<h1 class="auth">Tyler W. Rinker & Dason Kurkiewicz</h1>

The **pacman** package is an R package management tool that combines the functionality of base `library` related functions into intuitively named functions.  This package is ideally added to [.Rprofile](http://stat.ethz.ch/R-manual/R-patched/library/base/html/Startup.html) to increase workflow by reducing time recalling obscurely named functions, reducing code, and integrating functionality of base functions to simultaneously perform multiple actions.  The function `p_load` is particularly well suited for help forums and posts, as it will load and, if necessary, install missing packages.


```{r, echo=FALSE, results='asis', warning=FALSE}
uri_embed("r_pacman.png", 
    "width=\"350\", height=\"150\" style=\"display:block; margin-left:auto; margin-right:auto;\"")
```


Function names in the pacman package follow the format of `p_xxx` where 'xxx' is the task the function performs.  For instance the `p_load` function allows the user to load one or more packages as a more generic substitute for the `library` or `require` functions and if the package isn't available locally it will install it for you.  In keeping with the `library` function, the user need not use quotes around package names for most **pacman* functions.

<h2 id="loading"> Installing, Loading, Unloading, Updating, & Deleting </h2>

**Quick Reference Table** 

```{r, echo=FALSE, results='asis', warning=FALSE}
installing_tab <- readLines("tables/01_installing_loading_deleting.R")
cat(paste(installing_tab, collapse="\n"))
```

The heart of **pacman** is it's ability to reduce typing in package management actions.  The functions in this section The functions in this section ***act*** on packages.  

### Installing and Loading    

`p_load` is a general use tool that can install, load, and update packages.  The form for the function is:

```{r, eval = FALSE}
p_load(..., char, install = TRUE, update = getOption("pac_update"), character.only = FALSE)
```

where the `...` argument allows the user to pass in quoted (or unquoted) package names.  For example, many blog posts begin coding with this sort of package call:

```{r eval=FALSE}
packs <- c("XML", "devtools", "RCurl", "fakePackage", "SPSSemulate")
success <- suppressWarnings(sapply(packs, require, character.only = TRUE))
install.packages(names(success)[!success])
sapply(names(success)[!success], require, character.only = TRUE)
```

With pacman this call can be reduced to:

```{r eval=FALSE}
pacman::p_load(XML, devtools, RCurl, fakePackage, SPSSemulate)
```

#### Just Installing 

The user may wish to only install packages.  The `p_install` (aliased as `p_get`) will allow the user to install with the same ease of format as `p_load`.  For example: 

```{r eval=FALSE}
p_install(dbConnect, qdap, reports)
```

### Installing Temporarily

Lastly, `p_temp` enables the user to temporarily install a package.  This allows a session only install for testing out a single package without muddying the user's library.  

```{r eval=FALSE}
p_temp(aprof)

p_isinstalled(aprof)
p_isloaded(aprof)
```

<pre><code>> p_temp(aprof)
trying URL 'http://cran.rstudio.com/bin/windows/contrib/3.1/aprof_0.2.zip'
Content type 'application/zip' length 34037 bytes (33 Kb)
opened URL
downloaded 33 Kb

package 'aprof' successfully unpacked and MD5 sums checked

The downloaded binary packages are in
        C:\Users\you\AppData\Local\Temp\RtmpYh6bSr\downloaded_packages

aprof installed
Loading required package: aprof
> 
> p_isinstalled(aprof)
[1] FALSE
> p_isloaded(aprof)
aprof 
 TRUE 
</code></pre>

<div class="notebox", style="background-color: #FFFFCC;"> 
<b>Note:</b>  When using <code>p_load</code> and friends inside of functions the user may want to explicitly supply the package name(s) as character strings and set <code>character.only = FALSE</code> or supply a character vector of package names directly to the <code>char</code> argument if it is available.
</div>

       
###  Unloading

To unload package(s) from the search path use `p_unload`.  `p_unload` will not unload the base install packages that load when R boots up. The form for the function is:

```{r, eval = FALSE}
p_unload(..., negate = FALSE, char, character.only = FALSE)
```

where the `...` argument allows the user to pass in quoted package names.  Users may also supply `"all"` to `...`  to remove all add on packages.  The `negate` argument negates, unloading all packages except those supplied to `...`.

```{r, eval = FALSE}
p_load(lattice)
p_isloaded(lattice)
p_unload(lattice)
p_isloaded(lattice)
```

<pre><code>> p_load(lattice)
> p_isloaded(lattice)
lattice 
   TRUE 
> p_unload(lattice)
The following packages have been unloaded:
lattice

> p_isloaded(lattice)
lattice 
  FALSE 
</code></pre>

### Updating    
  
The `p_update` (aliased as `p_up`) is a wrapper for `update.packages` (defaults to `ask = FALSE`) and `old.packages`. To update packages use:

```{r, eval = FALSE}
p_update() 
```

The user may just query (not actually update) for out-of-date packages using:

```{r, eval = FALSE}
p_update(FALSE) 
```

### Deleting   
  
The task of recalling the name `remove.packages` for permanently deleting a package from your library has been replaced by the more consistently named `p_delete` (aliased as `p_del`).  Additionally, the user may delete multiple packages in a single call.  The function protects the user from accidental attempted base package deletion as it will not delete base installed packages (see `installed.packages(priority = "base")`).  Try it out:

```{r, eval = FALSE}
p_delete(fakePackage, stats)
```

<pre><code>> p_delete(fakePackage, stats)
The following packages are a base install and will not be deleted:
stats

The following packages not found in library:
fakePackage
</code></pre>

<h2 id="session_info"> Session Information  </h2>  

**Quick Reference Table** 

```{r, echo=FALSE, results='asis', warning=FALSE}
installing_tab <- readLines("tables/02_session_information.R")
cat(paste(installing_tab, collapse="\n"))
```

The `p_loaded` function allows the user to quickly determine what packages are attached.  

```{r, eval = FALSE}
p_loaded()
```

This returns non-base packages that are attached.  Adding `all = TRUE` will return the base packages as well.

```{r, eval = FALSE}
p_loaded(all = TRUE)
```

Supplying a package name to `p_loaded` (or alternatively `p_isloaded()`) provides a logical check of whether package(s) are attached:

```{r}
p_loaded(base, MASS)
p_isloaded(methods, stats)
```

<h2 id="local_package_info"> Local Package Information </h2>   

**Quick Reference Table** 

```{r, echo=FALSE, results='asis', warning=FALSE}
installing_tab <- readLines("tables/03_local_package_information.R")
cat(paste(installing_tab, collapse="\n"))
```

The finctions in this section provide information about a user's local packages.

### Package Existence (CRAN & Locally)

The `p_exists` cehcks if a package exists either on CRAN (default) or locally.  `p_isinstalled` is a convenience wrapper for `p_exists` that is defaulted to check local existence.

```{r}
p_exists(pacman)  
p_exists(pacman, cran = FALSE)
p_exists(I_dont_exist)
## wrapper for `p_exists(cran = FALSE)`
p_isinstalled(pacman)
```

### Package Attributes

The following subsections discuss **pacman** functions that are used to grab package information.

#### Package Information 

```{r, echo=FALSE, results='hide'}
.pinfo <- names(p_info())
.right_paren <- c(rep("(", length(.pinfo) - 1 ), "and (")
.fields <- paste(.right_paren, letters[1:length(.pinfo)], ") ", .pinfo, sep = "", collapse = ", ")
.fields <- gsub("(c)", "&#40;c)", .fields, fixed = TRUE)
```

`p_information` (aliased as `p_info`) is a more general use function to grab information about a package from its 'DESCRIPTION' file; for example, the following *fields* come from the **base** package: `r .fields`.  

The form for the function is:

```{r, eval = FALSE}
p_info(package, ..., fields = NULL)
```

where `package` is a package name and `...` argument allows the user to request specific fields (the `fields` argument is a character only ['escape hatch'](http://adv-r.had.co.nz/Computing-on-the-language.html#calling-from-another-function) for fields to use inside of functions). If both `...` and `fields` are blank, `p_info` returns a list of all package fields from the package 'DESCRIPTION' file.  `p_info` returns a `list`.


```{r}
## Defaults to supply a list of fields with information about R's base package
p_info()
names(p_info())
```

```{r}
p_info(pacman, Author)
p_info(pacman, BugReports, URL)
p_info(pacman, fields = "Version")
```

##### Extracting Package Names

<div class="notebox", style="background-color: #FFFFCC;"> 
<b>Note:</b> The <code>p_extract</code> function is particularly useful for converting the "Depends", "Imports", and, "Suggests" fields from a single string into a vector of package names.
</div>

```{r}
## without `p_extract`
p_info(MASS, "Depends")  
p_extract(p_info(MASS, "Depends"))
p_extract(p_info(methods, "Imports"))
```


#### Package Author   

`p_author` is a shortcut means of 

#### Package Citation

#### Package Data   

#### Package Functions

### Package Version

### Documentation

#### Package Help Manual

#### Package News

#### Package Vignette

### Interactive Package Exploration 

-  `p_author`
-  `p_cite`/`p_citation`
-  `p_data`
-  `p_exists`/`p_isinstalled`  
-  `p_funs`/`p_functions`
-  `p_help`
-  `p_inter`/`p_interactive`
-  `p_news`
-  `p_ver`/`p_version`
-  `p_vign`/`p_vignette`


<h2 id="internet_package_info"> Internet Based Package Information  </h2> 

**Quick Reference Table** 

```{r, echo=FALSE, results='asis', warning=FALSE}
installing_tab <- readLines("tables/04_internet_based_info.R")
cat(paste(installing_tab, collapse="\n"))
```

-  `p_cran`
-  `p_search_any`/`p_sa`

<h2 id="library_info"> Library Information  </h2>   

**Quick Reference Table** 

```{r, echo=FALSE, results='asis', warning=FALSE}
installing_tab <- readLines("tables/05_library_information.R")
cat(paste(installing_tab, collapse="\n"))
```

- `p_base`
- `p_lib`/`p_library`
- `p_path`
- `p_sl`/`p_search_library`
- `p_unlock`

<h2 id="pacman_tools"> pacman Tools  </h2>  

**Quick Reference Table** 

```{r, echo=FALSE, results='asis', warning=FALSE}
installing_tab <- readLines("tables/06_pacman_tools.R")
cat(paste(installing_tab, collapse="\n"))
```

- `p_detectOS` 
- `p_extract`
- `p_opendir`   

```{r css, echo = FALSE}
options(markdown.HTML.stylesheet = "css/style.css")
```

## References
```{r, echo=FALSE, message=FALSE}
#write.bibtex(file="references.bib")
```

```{r clean-up, include=FALSE}
# R compiles all vignettes in the same session, which can be bad
rm(list = ls(all = TRUE))
```
